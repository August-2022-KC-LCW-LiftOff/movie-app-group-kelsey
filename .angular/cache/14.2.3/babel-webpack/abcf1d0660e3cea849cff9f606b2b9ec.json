{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport { of, EMPTY, Observable, concat } from 'rxjs';\nimport { subscribeOn, observeOn, switchMap, map, shareReplay, switchMapTo, catchError, mergeMap, defaultIfEmpty } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { VERSION } from '@angular/fire';\nimport { ɵfirebaseAppFactory, ɵcacheInstance, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins } from '@angular/fire/compat';\nimport { isSupported } from 'firebase/messaging';\nimport firebase from 'firebase/compat/app'; // DO NOT MODIFY, this file is autogenerated by tools/build.ts\n// Export a null object with the same keys as firebase/compat/messaging, so Proxy can work with proxy-polyfill in Internet Explorer\n\nconst proxyPolyfillCompat = {\n  deleteToken: null,\n  getToken: null,\n  onMessage: null,\n  onBackgroundMessage: null\n};\nconst VAPID_KEY = /*#__PURE__*/new InjectionToken('angularfire2.messaging.vapid-key');\nconst SERVICE_WORKER = /*#__PURE__*/new InjectionToken('angularfire2.messaging.service-worker-registeration');\nlet AngularFireMessaging = /*#__PURE__*/(() => {\n  class AngularFireMessaging {\n    constructor(options, name, // tslint:disable-next-line:ban-types\n    platformId, zone, schedulers, vapidKey, _serviceWorker) {\n      const serviceWorker = _serviceWorker;\n      const messaging = of(undefined).pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(isSupported), switchMap(supported => supported ? import('firebase/compat/messaging') : EMPTY), map(() => ɵfirebaseAppFactory(options, zone, name)), switchMap(app => ɵcacheInstance(`${app.name}.messaging`, 'AngularFireMessaging', app.name, () => __awaiter(this, void 0, void 0, function* () {\n        return app.messaging();\n      }), [])), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      this.requestPermission = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(() => Notification.requestPermission()));\n      this.getToken = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(messaging => __awaiter(this, void 0, void 0, function* () {\n        if (Notification.permission === 'granted') {\n          const serviceWorkerRegistration = serviceWorker ? yield serviceWorker : null;\n          return yield messaging.getToken({\n            vapidKey,\n            serviceWorkerRegistration\n          });\n        } else {\n          return null;\n        }\n      })));\n      const notificationPermission$ = new Observable(emitter => {\n        navigator.permissions.query({\n          name: 'notifications'\n        }).then(notificationPerm => {\n          notificationPerm.onchange = () => emitter.next();\n        });\n      });\n      const tokenChange$ = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMapTo(notificationPermission$), switchMapTo(this.getToken));\n      this.tokenChanges = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(() => concat(this.getToken, tokenChange$)));\n      this.messages = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(messaging => new Observable(emitter => messaging.onMessage(emitter))));\n      this.requestToken = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(() => this.requestPermission), catchError(() => of(null)), mergeMap(() => this.tokenChanges));\n\n      this.deleteToken = () => messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(messaging => messaging.deleteToken()), defaultIfEmpty(false));\n\n      return ɵlazySDKProxy(this, messaging, zone);\n    }\n\n  }\n\n  AngularFireMessaging.ɵfac = function AngularFireMessaging_Factory(t) {\n    return new (t || AngularFireMessaging)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(VAPID_KEY, 8), i0.ɵɵinject(SERVICE_WORKER, 8));\n  };\n\n  AngularFireMessaging.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularFireMessaging,\n    factory: AngularFireMessaging.ɵfac,\n    providedIn: 'any'\n  });\n  return AngularFireMessaging;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\nɵapplyMixins(AngularFireMessaging, [proxyPolyfillCompat]);\nlet AngularFireMessagingModule = /*#__PURE__*/(() => {\n  class AngularFireMessagingModule {\n    constructor() {\n      firebase.registerVersion('angularfire', VERSION.full, 'fcm-compat');\n    }\n\n  }\n\n  AngularFireMessagingModule.ɵfac = function AngularFireMessagingModule_Factory(t) {\n    return new (t || AngularFireMessagingModule)();\n  };\n\n  AngularFireMessagingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFireMessagingModule\n  });\n  AngularFireMessagingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFireMessaging]\n  });\n  return AngularFireMessagingModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireMessaging, AngularFireMessagingModule, SERVICE_WORKER, VAPID_KEY }; //# sourceMappingURL=angular-fire-compat-messaging.js.map","map":null,"metadata":{},"sourceType":"module"}